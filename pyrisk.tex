\documentclass[12pt,a4paper]{article}
\begin{document}

\section{Introduction}

\textbf{PyRisk} is a minimal python implementation of the game Risk, intended as an AI competition platform.

The ruleset used is a lowest-common denominator version of basic Risk.
\begin{itemize}
\item Players start with 35 armies (2 player), 5 less for each additional player.
\item Territories are chosen in turn until all are taken, then remaining reinforcements are placed one-at-a-time.
\item Players receive one reinforcement per 3 territories held (minimum 3) and bonuses for continents held.
\item Players may attack as many times as they want, with attackers rolling up to 3 dice and defenders up to 2, winning on a tie. Attacks can be broken off after each round.
\item Defenders may choose to roll one or two dies after seeing the attack roll.
\item After all other actions a single free move is permitted, between any two territories\footnote{There is currently no constraint that these are connected by friendly territories, but this may be added}.
\item Highlander victory conditions. \textbf{There can be only one}.
\end{itemize}

\subsection{Usage}

\textit{python RiskRunner.py [options] AIName0 AIName1...}

\textit{python RiskRunner.py --help}

By default the ncurses UI is displayed, and a single game played.

\begin{tabular}{ll}
-x&Disable ncurses\\
-c&Enable ncurses colour mode (experimental)\\
-s&Enable stdout\\
-l file&Enable logging\\
-n X&Run X games\\
\end{tabular}

For debugging, you probably want to use \textit{-xs} mode, as the ncurses mode will not show exceptions, but just exit.

\section{AI Development}

This was mainly intended to be an AI testbed. AIs in this case are python classes inheriting from (or at least implementing all the methods from) AIBase. Default implementations of most or all methods are provided by AIBase, but you will of course want to override them.

Most objects in the game (continents, players, territories) have both a string name and an object containing the relevant data. AI communication with the game (attacking etc) is done by providing the name rather than the object (as the objects visible to the AI are deep copies to avoid AIs messing with the internal state).

\subsection{Game Information}

The game provides copied versions of some internal data structures to your AI, which you use to get information about the territories, continents, other players and the player you represent.

These classes are updated by the game rather than overwritten, so you can add your own attributes without them getting removed at each update (providing they don't use the names of basic class members).

\begin{tabular}{ll}
last\_error&Tuple containing information about the last error your AI caused, if any. Errors are otherwise silently ignored, except during initial placement when they raise an exception (that stops the game, you cannot handle it).\\
game\_self&Copy of the pyrisk.Player object representing you. Contains your force count, projected reinforcements, list of territories and continents, etc.\\
game\_players&Dictionary of player names to pyrisk.Player objects for each player (including yourself).\\
game\_areas&Dictionary of continent name to pyrisk.Area object for each area. Contains list of territories, value of this continent and the current owner.\\
game\_territories&Dictionary of territory name to pyrisk.Territory object for each territory. These contain current owner, current forces and a list of adjacent territories.\\
\end{tabular}

\subsection{Game Startup}

At the beginning of the game, the function \textbf{prepare()} is called with no arguments. No return value is expected.

When force placement starts, the function \textbf{placeForces(empty\_territories, remaining\_forces)} is called repeatedly. While there are unclaimed territories remaining, empty\_territories is a list of names, otherwise it is None. The return value is in both cases the name of a territory to claim or to reinforce by one army. While there are empty territories the return value must be one of the empty list.

Any errors caused at this time cause the game to raise an exception, as empty territories etc being left would break core game assumptions.

\subsection{Reinforcement}

At the start of each turn, \textbf{placeReinforcements(count)} is called once. You need to analyse the map and determine all your force placements. This can either be a generator function that repeatedly yields (territory\_name, reinforcements), or a normal function that returns a list [(name,n),(name,n)...].

Errors are handled silently (if you attempt to reinforce enemy territories, more reinforcements than you have, or leave some unused). The last\_error tuple will be set after any bad actions.

\subsection{Attacking}

After the reinforcement phase, \textbf{turnAttacks()} is called with no arguments. As with reinforcing, this is called once and needs to either return a list of actions or repeatedly yield actions. Each action is a tuple of the form (origin, target, strategy).

Strategy in most cases will be None, meaning never stop attacking and commit all forces. If you want finer control, you can provide one of several preset strings or a function of your own. If you want custom options, you provide a tuple (condition, move).

The condition argument is either a function \textbf{f(attackers, defenders)} that returns True or False to determine whether to keep attacking. Alternatively, you can provide one of the strings:

\begin{tabular}{ll}
always&Do or die.\\
more&Continue attacking while \math{atk>def}\\
minN&Continue attacking while \math{atk>N}\\
ratioF&Continue attacking while \math{\frac{atk}{def}>N}\\
diffN&Continue attacking while \math{atk-def>N}\\
\end{tabular}

The move argument is either a function \textbf{f(attackers, defenders)} which returns the number of troops you want to move if you are victorious (less any you loose this round). If you return a number less than 3 then that number of attack dies will be used. Alternatively you can provide one of these strings, or an integer (in which case that number will always be used).

\begin{tabular}{ll}
max&Move everyone.\\
half&Move half your remaining troops.\\
min&Move the minimum for a full attack (ie 3).\\
\end{tabular}

The defender's choice of die rolls is made by calling the function \textbf{defendTerritory(atk\_roll, attackers, defenders)}, which should return either 1 or 2, depending on the die roll (which is sorted highest-first).

\subsection{Free Move}

The function \textbf{freeMove()} is called with no arguments after all attacks are finalised. The return value should be None or a tuple (origin, destination, number).

\subsection{Finalise}

When the game ends, the function \textbf{finalise()} is called. This can be used to save any data if required, close any resources, etc. If desirable, some post-mortem information can be returned, for later statistical use. An example of this might be which continent the AI targetted first, or other things that could compute interesting statistics at the end. There is no standard for such info at this time, and custom extensions would be needed to collate them.

\end{document}